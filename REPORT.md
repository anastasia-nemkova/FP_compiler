# Отчет по лабораторной работе
## по курсу "Функциональное и логическое программирование"

**Студенты:**
| ФИО |  Роль в проекте |
|-|-|
| Былькова К. А. | Разработка парсера, написание отчета |
| Немкова А. Р. | Разработка интерпретатора, обработка ошибок |
| Старостина А. А. | Разработка синтаксического дерева, написание отчета |

## Цель работы
Придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

## Язык GG
Нами был придуман и написан язык GG. Он следует парадигме функционального программирования на основе либо лямбда-исчисления. Также наш язык позволяет запрограммировать функцию для расчета факториала. Комментарии в нашем языке выделяются с помощью знака #. Следует отметить, что синтаксис нашего языка требует, чтобы анализируемые деревья имели только один корень, поэтому все языковые программы имеют дополнительные внешние скобки.
Также было создано расширение для VSCode.

## Реализованные функции
Здесь представлены функции, которые реализованы в нашем языке.
* Именованные переменные (`let`)
* Рекурсия
* Ленивое вычисление
* Функции
* Замыкания
* Библиотечные функции: ввод-вывод файлов

## Синтаксическое дерево
Структура нашего синтаксического дерева основана на комбинировании узлов Expr. Например, операторы и их операнды объединяются в узлы OPERATOR, цикл for представляется в узле FOR_LOOP, цикл while в узле WHILE, а условные выражения - узлами COND.

Благодаря тому, что узлы дерева могут включать в себя друг друга, у нас есть возможность комбинировать их и представлять сложные структуры и выражения. Ниже представлены реализованные структуры.
| Тип | Описание |
|-|-|
| OPERATOR | Операторы и списки параметров |
| NUMBER | Числовые значения |
| STRING | Строковые значения |
| ID | Именованные переменные |
| BOOL | Булевые значения |
| COND | Условные выражения |
| SET | Переменная со значением |
| FUNC | Функции |
| CALL | Вызов функции |
| PRINT | Печать |
| READ_FILE | Чтение файла |
| WRITE_FILE | Запись в файл |
| FOR_LOOP | Цикл for |
| WHILE | Цикл while |
| CONTINUE | Продолжение цикла |
| KILL | Остановка цикла |

Наша программа принимает вводные строки и разделяет их на отдельные части, называемые токенами. Далее, анализируя эти токены, выполняет парсинг. В процессе анализа, мы сопоставляем токены с предопределенными шаблонами из BASE и создаем структуры данных, называемые BASELIST. А BASEARGLIST служит для идентификации аргументов функций, которые заключены в фигурные скобки {}. Функции представляются в виде [NAME; ARGS; BODY].

## Парсер
//
## Интерпретатор
//
## Примеры
* Вывод
```
(print "Hello world")
```
* Простейшие операции
```
(var a = 2.0)
(var c = 10.0)
(print (+ a c))
```
* Булевы операции
```
(
    print(& 1 0)
)
```
* Условия
```
(
    if(== 2 3) :
        (print "true")
    else :
        (print "false")
)
```
* Цикл for
```
(
    for i [0 .. 3] :
        (print i)
)
```
* Цикл while
```
(func fun {s} :
    (   
        while (< s 10) :
            ((print s) 
            (fun (+ s 1)))
    )
) 
(fun 1)
```
* Функции
```
(
    func printNum {num} :
        (print num)
)
```
* Работа с файлами
```
(print(read "/home/arnemkova/FP_labs/lab2/src/Main/test.txt"))
(write "/home/arnemkova/FP_labs/lab2/src/Main/test.txt" "MIAY")
```
* Факториал
```
(func fact {n} :
    (
        if(== n 0) :
            1
        else :
            (* n (fact (- n 1)))
    )
)
(print (fact 5))
```
## Заключение
В результате данной лабораторной работы был придуман и написан наш собственный функциональный язык программирования, позволяющий выполнять простейшие операции над числами и строками. Также были реализованы условия, циклы, рекурсия и возможна работа с файлами. Были получены знания о том, как писать свой собственный парсер и интерпретатор, что однозначно пригодится в будущем при выполнении более серьезных работ. 
